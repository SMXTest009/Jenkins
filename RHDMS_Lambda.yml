
AWSTemplateFormatVersion: "2010-09-09"
Metadata:
    Generator: "former2"
Description: ""
Resources:  #Roles are listed here should be deployed with other roles using the RHDMS_IAM_Roles.yml
    # IAMRole1:
    #     Type: "AWS::IAM::Role"
    #     Properties:
    #         Path: "/"
    #         RoleName: "BREAKGLASS-IAM-ROLE-Usage-BreakGlassUsageLambdaRol-EMNS3QCA2MBQ"
    #         AssumeRolePolicyDocument: 
    #           Version: "2012-10-17"
    #           Statement:
    #             - 
    #               Effect: "Allow"
    #               Principal:
    #                 Service:
    #                   - "lambda.amazonaws.com"
    #               Action:
    #                 - "sts:AssumeRole"
    #         MaxSessionDuration: 3600
    #         ManagedPolicyArns: 
    #           - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
    #         Description: "Role for BREAKGLASS usage notification"
    #         Tags: 
    #           - 
    #             Key: "BrokerManaged"
    #             Value: "true"
    # IAMRole2:
    #     Type: "AWS::IAM::Role"
    #     Properties:
    #         Path: "/"
    #         RoleName: "StackSet-Sec-Hub-Automate-SecHubRemediationLambdaR-1ARPKWZ6VEE8O"
    #         AssumeRolePolicyDocument: 
    #           Version: "2012-10-17"
    #           Statement:
    #             - 
    #               Effect: "Allow"
    #               Principal:
    #                 Service:
    #                   - "lambda.amazonaws.com"
    #               Action:
    #                 - "sts:AssumeRole"
    #         MaxSessionDuration: 3600
    #         ManagedPolicyArns: 
    #           - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
    #         Description: ""
    #         Tags: 
    #           - 
    #             Key: "BrokerManaged"
    #             Value: "true"
    
    # IAMRole3:
    #     Type: "AWS::IAM::Role"
    #     Properties:
    #         Path: "/"
    #         RoleName: "StackSet-IAM-User-Passwor-IamPasswordPolicyLambdaR-1K741NKBW7ITW"
    #         AssumeRolePolicyDocument: 
    #           Version: "2012-10-17"
    #           Statement:
    #             - 
    #               Effect: "Allow"
    #               Principal:
    #                 Service:
    #                   - "lambda.amazonaws.com"
    #               Action:
    #                 - "sts:AssumeRole"
    #         MaxSessionDuration: 3600
    #         ManagedPolicyArns: 
    #           - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
    #         Description: ""
    #         Tags: 
    #           - 
    #             Key: "BrokerManaged"
    #             Value: "true"

    # IAMRole4:
    #     Type: "AWS::IAM::Role"
    #     Properties:
    #         Path: "/"
    #         RoleName: "StackSet-Chronos-3c78eaa1-de17-4-ChronosLambdaRole-1LCK21SC65AH6"
    #         AssumeRolePolicyDocument: 
    #           Version: "2012-10-17"
    #           Statement:
    #             - 
    #               Effect: "Allow"
    #               Principal:
    #                 Service:
    #                   - "lambda.amazonaws.com"
    #               Action:
    #                 - "sts:AssumeRole"
    #         MaxSessionDuration: 3600
    #         ManagedPolicyArns: 
    #           - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
    #         Description: "Role to provide chronos with ec2 start, ec2 stop, and ec2 tag read"
    #         Tags: 
    #           - 
    #             Key: "BrokerManaged"
    #             Value: "true"

    # IAMRole5:
    #     Type: "AWS::IAM::Role"
    #     Properties:
    #         Path: "/"
    #         RoleName: "StackSet-Enable-S3-Defaul-S3DefaultEncryptionLambd-1H0RC12HDOGZB"
    #         AssumeRolePolicyDocument: 
    #           Version: "2012-10-17"
    #           Statement:
    #             - 
    #               Effect: "Allow"
    #               Principal:
    #                 Service:
    #                   - "lambda.amazonaws.com"
    #               Action:
    #                 - "sts:AssumeRole"
    #         MaxSessionDuration: 3600
    #         ManagedPolicyArns: 
    #           - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
    #         Description: ""
    #         Tags: 
    #           - 
    #             Key: "BrokerManaged"
    #             Value: "true"

    # IAMRole6:
    #     Type: "AWS::IAM::Role"
    #     Properties:
    #         Path: "/service-role/"
    #         RoleName: "IAM_ACCESS_KEY_ROTATED-role-x58uyjup"
    #         AssumeRolePolicyDocument: 
    #           Version: "2012-10-17"
    #           Statement:
    #             - 
    #               Effect: "Allow"
    #               Principal:
    #                 Service:
    #                   - "lambda.amazonaws.com"
    #               Action:
    #                 - "sts:AssumeRole"
    #         MaxSessionDuration: 3600
    #         ManagedPolicyArns: 
    #           - !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/service-role/AWSLambdaBasicExecutionRole-5e06fb8e-0437-4e94-a711-e570cb6c7569"

    # IAMRole7:
    #     Type: "AWS::IAM::Role"
    #     Properties:
    #         Path: "/"
    #         RoleName: "StackSet-Enable-S3-Block-S3BlockPublicAccessLambd-1I9CCEY5M5VSF"
    #         AssumeRolePolicyDocument: 
    #           Version: "2012-10-17"
    #           Statement:
    #             - 
    #               Effect: "Allow"
    #               Principal:
    #                 Service:
    #                   - "lambda.amazonaws.com"
    #               Action:
    #                 - "sts:AssumeRole"
    #         MaxSessionDuration: 3600
    #         ManagedPolicyArns: 
    #           - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
    #         Description: ""
    #         Tags: 
    #           - 
    #             Key: "BrokerManaged"
    #             Value: "true"

    # IAMRole8:
    #     Type: "AWS::IAM::Role"
    #     Properties:
    #         Path: "/"
    #         RoleName: "StackSet-CMK-EBS-Encrypti-Ec2DefaultEncryptionLamb-12XJHSL1JPY22"
    #         AssumeRolePolicyDocument: 
    #           Version: "2012-10-17"
    #           Statement:
    #             - 
    #               Effect: "Allow"
    #               Principal:
    #                 Service:
    #                   - "lambda.amazonaws.com"
    #               Action:
    #                 - "sts:AssumeRole"
    #         MaxSessionDuration: 3600
    #         ManagedPolicyArns: 
    #           - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
    #           - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonEC2FullAccess"
    #         Description: ""
    #         Tags: 
    #           - 
    #             Key: "BrokerManaged"
    #             Value: "true"

    # IAMRole9:
    #     Type: "AWS::IAM::Role"
    #     Properties:
    #         Path: "/"
    #         RoleName: "CloudSSnorkel-CloudWatch2S3-addi-LogSubscriberRole-QN0CSDTF91QN"
    #         AssumeRolePolicyDocument: 
    #           Version: "2012-10-17"
    #           Statement:
    #             - 
    #               Effect: "Allow"
    #               Principal:
    #                 Service:
    #                   - "lambda.amazonaws.com"
    #               Action:
    #                 - "sts:AssumeRole"
    #         MaxSessionDuration: 3600
    #         ManagedPolicyArns: 
    #           - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
    #         Description: ""

    # IAMRole10:
    #     Type: "AWS::IAM::Role"
    #     Properties:
    #         Path: "/service-role/"
    #         RoleName: "iamUserCleanUp-role-vzaub88e"
    #         AssumeRolePolicyDocument: 
    #           Version: "2012-10-17"
    #           Statement:
    #             - 
    #               Effect: "Allow"
    #               Principal:
    #                 Service:
    #                   - "lambda.amazonaws.com"
    #               Action:
    #                 - "sts:AssumeRole"
    #         MaxSessionDuration: 3600
    #         ManagedPolicyArns: 
    #           - !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/service-role/AWSLambdaBasicExecutionRole-717ddb22-06cf-4fe1-9e77-021799c74833"

    LambdaFunction:
        Type: "AWS::Lambda::Function"
        Properties:
            Description: "Sends email alert when BreakGlass role is assumed"
            FunctionName: "BREAKGLASS-IAM-ROLE-Usage-BreakGlassUsageLambdaFun-dCzxuKtu30Eh"
            Handler: "index.lambda_handler"
            Code: 
              ZipFile: |
                import boto3
                
                def lambda_handler(event, context):
                    email_recipient = ['support@c2sconsultinggroup.com']
                    details = event['detail']
                    switch_role = details.get('additionalEventData').get('SwitchTo')
                    source_arn = details.get('userIdentity').get('arn')
                    event_id = details.get('eventID')
                    success = details.get('responseElements').get('SwitchRole')
                    time = details.get('eventTime')
                    account = details.get('recipientAccountId')
                    print(f"ALERT Switch Role to {switch_role} from {source_arn} with a status of {success} has been detected")
                    
                    msg_subject = f"""
                        **ALERT** A SwitchRole has been performed on the BREAKGLASS Role in AWS account {account}'
                    """

                    msg_body = f"""
                        Description: User {source_arn} has performed a Switch Role into role {switch_role} with a status of {success}. <br>
                        <br>
                        Source ARN: {source_arn} <br>
                        Switch Role ARN: {switch_role} <br>
                        Switch Role Status: {success} <br>
                        Account ID: {account} <br>
                        Event ID: {event_id} <br>
                        Event Time: {time} <br>
                    """

                    boto3.client('ses').send_email(
                      Source= 'support@c2sconsultinggroup.com',
                      Destination={
                          'ToAddresses': email_recipient
                      },
                      Message={
                          'Subject': {
                              'Data': msg_subject,
                              'Charset': 'UTF-8'
                          },
                          'Body': {
                              'Text': {
                                  'Data': msg_body.replace('<br>','\n'),
                                  'Charset': 'UTF-8'
                              },
                              'Html': {
                                  'Data': f'<html>{msg_body}</html>',
                                  'Charset': 'UTF-8'
                              }
                          }
                      },
                    )
            MemorySize: 128
            Role: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/BREAKGLASS-IAM-ROLE-Usage-BreakGlassUsageLambdaRol-EMNS3QCA2MBQ"
            Runtime: "python3.9"
            Timeout: 10

    LambdaFunction2:
        Type: "AWS::Lambda::Function"
        Properties:
            Description: "Lambda function to remediate Security Hub findings"
            Environment: 
                Variables: 
                    FLOW_LOGS_ROLE_ARN: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/StackSet-Sec-Hub-Automate-SecHubRemediationFlowLog-RBXOFHRORWDQ"
            FunctionName: "SecHubRemediation"
            Handler: "sec_hub_remediations.main"
            Code: 
                ZipFile: |
                  import logging
                  import time
                  import boto3
                  import os
                  from botocore.exceptions import ClientError


                  logger = logging.getLogger()
                  logger.setLevel(logging.INFO)


                  def rem_ec2_18_19(event, ctr_id, fun_arn):
                      '''Used to remediate SecHub finding EC2.19 Security groups should 
                      not allow unrestricted access to ports with high risk and EC2.18 
                      Security groups should only allow unrestricted incoming traffic 
                      for authorized ports'''    
                      

                      def get_unrestricted_sg_rule_ids(sec_group_id, client):
                          '''Inner helper function used to return a list of security group rule 
                          ids for rules allowing unrestricted access from restricted_ports'''

                          unrestricted_ports = [80,443]

                          group_rule_ids = list()

                          try:
                              sec_group_resp = client.describe_security_group_rules(
                                  Filters=[{'Name': 'group-id', 'Values': [sec_group_id]}])
                              
                              for sg_id in sec_group_resp.get('SecurityGroupRules'):
                                  if sg_id.get('IsEgress'):
                                      continue
                                  if not sg_id.get('ToPort') in unrestricted_ports:
                                      group_rule_ids.append(sg_id.get('SecurityGroupRuleId'))
                          except ClientError as error:
                              raise error        
                          except Exception as e:
                              raise e        
                          
                          return group_rule_ids


                      def revoke(sg_rule_ids, sec_group_id, client):
                          '''Inner helper function used to revoke security group ingress 
                          rules'''

                          try:
                              client.revoke_security_group_ingress(
                                  GroupId=sec_group_id,SecurityGroupRuleIds=sg_rule_ids)
                          except ClientError as error:
                              raise error
                          except Exception as e:
                              raise e


                      try:
                          ec2 = boto3.client('ec2')
                          findings = event.get('detail').get('findings')[0]
                          resources = findings.get('Resources')[0]
                          sec_group_id = str(resources.get('Id')).split('/')[-1]        
                          finding_id = str(findings.get('Id'))
                          sec_hub_arn = str(findings.get('ProductArn'))
                          resp = f"Successfully remediated Security Hub Finding Control ID {ctr_id}"
                          no_rem_resp = f"Remediation occured before automated remediation of {ctr_id}"
                          itr = 0
                          while itr < 5:
                              time.sleep(itr)
                              sec_group_rule_ids = get_unrestricted_sg_rule_ids(
                                  sec_group_id, ec2)
                              if not sec_group_rule_ids:
                                  break
                              revoke_sec_group_rule = revoke(sec_group_rule_ids, sec_group_id, ec2)       
                              itr += 1 
                      except Exception as e:
                          logger.error(e)
                          return f"An Error occured - {e}"
                      else:
                          try:
                              if itr:
                                  update_resp = update_control_finding(
                                      finding_id, sec_hub_arn, resp, fun_arn)
                              else:
                                  update_resp = no_rem_resp
                          except ClientError as error:
                              raise error
                          except Exception as e:
                              raise e
                          else:
                              return update_resp 


                  def rem_ec2_2(event, ctrl_id, fun_arn):
                      '''Will remediate SecHub finding EC2.2 The VPC default security 
                      group should not allow inbound and outbound traffic'''
                      
                      findings = event.get('detail').get('findings')[0]
                      resources = findings.get('Resources')[0]
                      def_sg_id = str(resources.get('Id')).split('/')[-1]        
                      finding_id = str(findings.get('Id'))
                      sec_hub_arn = str(findings.get('ProductArn'))
                      rem_text = f"Successfully remediated Security Hub Finding Control ID {ctrl_id} by removing ingress and egress rules from the default SG {def_sg_id}."
                      
                      try:
                          ec2_client = boto3.client('ec2')
                          default_sg = ec2_client.describe_security_groups(GroupIds=[def_sg_id])
                          default_sg_ingress = default_sg['SecurityGroups'][0]['IpPermissions']
                          default_sg_egress = default_sg['SecurityGroups'][0]['IpPermissionsEgress']
                          if(default_sg_ingress):
                              revoke_ingress = ec2_client.revoke_security_group_ingress(GroupId=def_sg_id, IpPermissions=default_sg_ingress)
                          if(default_sg_egress):
                              revoke_egress = ec2_client.revoke_security_group_egress(GroupId=def_sg_id, IpPermissions=default_sg_egress)
                      except ClientError as error:
                          raise error
                      except Exception as e:
                          raise e
                      else:
                          up_resp = update_control_finding(finding_id, sec_hub_arn, rem_text, fun_arn)
                          return up_resp
                          

                  def rem_autoscaling_1(event, ctrl_id, fun_arn):
                      '''This function remediates SecHub finding AutoScaling.1
                      Auto scaling groups associated with a load balancer should use load 
                      balancer health checks. **Health Check Value Assigned=300**
                      '''
                      
                      findings = event.get('detail').get('findings')[0]
                      resources = findings.get('Resources')[0]
                      asg_name = str(resources.get('Id')).split('/')[-1]        
                      finding_id = str(findings.get('Id'))
                      sec_hub_arn = str(findings.get('ProductArn'))
                      rem_text = f"Successfully remediated Security Hub Finding Control ID {ctrl_id} by updating the health check grace period of {asg_name} to 300."

                      try:
                          asg_client=boto3.client('autoscaling')
                          asg_name=str(event.get('detail').get('findings')[0].get('Resources')[0].get('Id')).split('/')[-1]
                          asg_name=str(event.get('detail').get('findings')[0].get('Resources')[0].get('Id')).split('/')[-1]
                          enable_lb_healthcheck = asg_client.update_auto_scaling_group(
                              AutoScalingGroupName=asg_name,
                              HealthCheckType='ELB',
                              HealthCheckGracePeriod=300
                          )
                      except ClientError as error:
                          raise error
                      except Exception as e:
                          raise e
                      else:
                          up_resp = update_control_finding(finding_id, sec_hub_arn, rem_text, fun_arn)
                          return up_resp


                  def rem_ec2_6(event, ctrl_id, fun_arn):
                      """Remediate SecHub finding EC2.6 VPC flow logging should be enabled in all VPCs
                      Enable VPC Flow logs
                      """

                      findings = event.get('detail').get('findings')[0]
                      resources = findings.get('Resources')[0]
                      vpc_id = str(resources.get('Id')).split('/')[-1]        
                      finding_id = str(findings.get('Id'))
                      sec_hub_arn = str(findings.get('ProductArn'))
                      rem_text = f"Successfully remediated Security Hub Finding Control ID {ctrl_id} by enableing flow logs for {vpc_id}."
                      
                      try:
                          cwl_client = boto3.client('logs')
                          log_group_name = f"/VpcFlowLogs/{vpc_id}"
                          create_log_group = cwl_client.create_log_group(
                              logGroupName=log_group_name
                              )
                      except ClientError as error:
                          raise error
                      except Exception as e:
                          raise e
                      else:
                          try:
                              time.sleep(3)
                              ec2_client = boto3.client('ec2')
                              enable_flow_logs = ec2_client.create_flow_logs(
                                  DeliverLogsPermissionArn=os.environ['FLOW_LOGS_ROLE_ARN'],
                                  LogGroupName=log_group_name,
                                  ResourceIds=[vpc_id],
                                  ResourceType='VPC',
                                  TrafficType='REJECT',
                                  LogDestinationType='cloud-watch-logs'
                                  )
                          except ClientError as error:
                              raise error
                          except Exception as e:
                              raise e
                          else:
                              up_resp = update_control_finding(finding_id, sec_hub_arn, rem_text, fun_arn)
                              return up_resp


                  def update_control_finding(finding_id, sec_hub_arn, rem_text, fun_arn):
                      'Update security hub finding control finding'
                      
                      try:
                          sec_hub = boto3.client('securityhub')
                          sec_hub.batch_update_findings(
                              FindingIdentifiers=[
                                  {
                                      'Id': finding_id,
                                      'ProductArn': sec_hub_arn
                                  }
                              ],
                              Note={
                                  'Text': rem_text,
                                  'UpdatedBy': fun_arn
                              },
                              Workflow={
                                  'Status': 'RESOLVED'
                              }
                          )
                      except ClientError as error:
                          raise error
                      except Exception as e:
                          raise e
                      else:
                          return rem_text

                    
                  def main(event, context):
                      '''Handler for sec hub eventbridge auto-remediation.'''

                      logger.info(f'event: {event}')
                      ctrl_id = event.get('detail').get('findings')[0].get('Title').split()[0]
                      source_account_id = event.get('detail').get('findings')[0].get('AwsAccountId')
                      fun_arn = context.invoked_function_arn
                      aws_account_id = fun_arn.split(":")[4]

                      if source_account_id != aws_account_id:
                          return

                      logger.info(f'EVENT TRIGGER = {ctrl_id}')
                      logger.info(f'FUNCTION ARN = {fun_arn}')

                      try:
                          if (ctrl_id == 'EC2.18' or ctrl_id == 'EC2.19'):
                              rem_response = rem_ec2_18_19(event, ctrl_id, fun_arn)
                          if (ctrl_id == 'EC2.2'):
                              rem_response = rem_ec2_2(event, ctrl_id, fun_arn)
                          if (ctrl_id == 'AutoScaling.1'):
                              rem_response = rem_autoscaling_1(event, ctrl_id, fun_arn)
                          if (ctrl_id == 'EC2.6'):
                              rem_response = rem_ec2_2(event, ctrl_id, fun_arn)
                      except ClientError as error:
                          logger.error(error)
                      except Exception as e:
                          logger.error(e)
                      else:
                          logger.info(rem_response)
            MemorySize: 128
            Role: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/StackSet-Sec-Hub-Automate-SecHubRemediationLambdaR-1ARPKWZ6VEE8O"
            Runtime: "python3.9"
            Timeout: 15

    LambdaFunction3: #  -- invoke function
        Type: "AWS::Lambda::Function"
        Properties:
            Description: ""
            FunctionName: "StackSet-IAM-User-Password-IamPasswordPolicyLambda-eZBgqNr6grEu"
            Handler: "index.handler"
            Code: 
              ZipFile: |
                import boto3
                import cfnresponse
                from botocore.exceptions import ClientError
                
                
                def handler(event, context):
                    
                    cfn_request = event['RequestType']
                    iam_resource = boto3.resource('iam')
                    account_password_policy = iam_resource.AccountPasswordPolicy()
                    HardEx = bool(event['ResourceProperties']['HardExpiry'])
                    UsersChangPW = bool(event['ResourceProperties']['AllowUsersToChangePassword'])
                    MaxPassAge = int(event['ResourceProperties']['MaxPasswordAge'])
                    MinPassLength = int(event['ResourceProperties']['MinimumPasswordLength'])
                    PassReuse = int(event['ResourceProperties']['PasswordReusePrevention'])
                    ReqLower = bool(event['ResourceProperties']['RequireLowercaseCharacters'])
                    ReqNumber = bool(event['ResourceProperties']['RequireNumbers'])
                    ReqSymbol = bool(event['ResourceProperties']['RequireSymbols'])
                    ReqUpper = bool(event['ResourceProperties']['RequireUppercaseCharacters'])
                    
                    if cfn_request == 'Delete':
                        print("Deleting IAM_PASSWORD_POLICY CloudFormation...")
                        cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                        return
                    try:
                        response = account_password_policy.update(
                            MinimumPasswordLength=MinPassLength,
                            RequireSymbols=ReqSymbol,
                            RequireNumbers=ReqNumber,
                            RequireUppercaseCharacters=ReqUpper,
                            RequireLowercaseCharacters=ReqLower,
                            AllowUsersToChangePassword=UsersChangPW,
                            MaxPasswordAge=MaxPassAge,
                            PasswordReusePrevention=PassReuse,
                            HardExpiry=HardEx)
                    except ClientError as e:
                        print(
                            f"FAILED to {cfn_request} IAM Account Password Policy -"
                            f"{e.response['Error']['Message']}")
                        cfnresponse.send(
                            event, context, cfnresponse.FAILED, e.response)
                    except Exception as ex:
                        print(
                            f"FAILED to {cfn_request} IAM Account Password Policy -"
                            f"{ex}")
                        cfnresponse.send(
                            event, context, cfnresponse.FAILED, 'Check log for failure.')
                    else:
                        print("SUCCESS in updating IAM Account Password Policy")
                        cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
            MemorySize: 128
            Role: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/StackSet-IAM-User-Passwor-IamPasswordPolicyLambdaR-1K741NKBW7ITW"
            Runtime: "python3.8"
            Timeout: 120

    LambdaFunction4: #   -- invoke function
        Type: "AWS::Lambda::Function"
        Properties:
            Description: "Lambda function to stop and start ec2"
            FunctionName: "Chronos"
            Handler: "chronos.main"
            Code: 
              ZipFile: |
                import logging
                import boto3
                from datetime import datetime as dt
                import math
                from croniter import croniter
                from datetime import timedelta


                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                ec2 = boto3.client('ec2')


                def describe_tags(tag_stop, tag_start, payload = {'NextToken': ''}):
                    '''Returns ec2 instances with the chronos_start and chronos_stop tags'''

                    response = ec2.describe_tags(
                        Filters=[
                            {
                                'Name': 'resource-type',
                                'Values': [
                                    'instance'
                                ]
                            },
                            {
                                  'Name': 'key',
                                'Values': [
                                    tag_start,
                                    tag_stop
                                ]      
                            },
                        ],
                        NextToken=payload['NextToken']
                    )

                    if 'Tags' in payload:
                        response['Tags'].extend(payload['Tags'])

                    if 'NextToken' in response:
                        return describe_tags(tag_stop, tag_start, response)
                    else:
                        return response['Tags']


                def in_action_window(tag, instance_id, current_time, interval):
                    '''Returns a boolean for the current resource based on the current start 
                    stop window.'''

                    cron_format_error = (
                        f'Current chronos tag {tag} has failed cron format validation for '
                        f'instance {instance_id}')
                    
                    if not croniter.is_valid(tag):
                        logger.error (cron_format_error)
                        return False

                    yr, mth, d, hr, min = [
                        int(i) for i in current_time.strftime("%Y %-m %-d %-H %-M").split()]
                    bottom_min = math.floor(min / interval) * interval 
                    top_min = bottom_min + interval - 1
                    bottom_interval = dt(yr, mth, d, hr, bottom_min) - timedelta(0,1)
                    top_interval = dt(yr, mth, d, hr, top_min, 59)
                    cron_dt = croniter(tag, bottom_interval)
                    cron_next = cron_dt.get_next(dt)

                    if (cron_next >= bottom_interval) and (cron_next <= top_interval):
                        return True
                    else:
                        return False


                def filter_stop_and_start(all_tags, now, interval, tag_stop, tag_start):
                    '''Retuns two lists of tags that fit into the current time window for 
                    either stopping or starting. The first list contains instances that are 
                    tagged with the tag_stop value. The second list contains tag_start.'''

                    chronos_stop = list()
                    chronos_start = list()

                    for i in all_tags:
                        resrc_id = i['ResourceId']
                        key_val = i['Value']
                        key = i['Key']
                        stop_tag = key_val if key == tag_stop else ''
                        start_tag = key_val if key == tag_start else ''
                        if stop_tag:
                            in_stop_window = in_action_window(
                                stop_tag, resrc_id, now, interval)
                            if in_stop_window:
                                chronos_stop.append(resrc_id)        
                        elif start_tag:
                            in_start_window = in_action_window(
                                start_tag, resrc_id, now, interval)
                            if in_start_window:
                                chronos_start.append(resrc_id)

                    return chronos_stop, chronos_start


                def stop_ec2(instance_ids):
                    '''Stops ec2 instance'''

                    try: 
                        ec2.stop_instances(InstanceIds=instance_ids)
                    except Exception as e:
                        logger.error(f'Ran into the following error: {e}')
                        logger.error(
                            f'As a result instance(s): {instance_ids} may not have been '
                            'stopped.')
                    else:
                        logger.info(
                            'Successfully initiated stop_instances on the following '
                            f'instance(s): {instance_ids}')


                def start_ec2(instance_ids):
                    '''Starts ec2 instance'''

                    try:
                        ec2.start_instances(InstanceIds=instance_ids)
                    except Exception as e:
                        logger.error(f'Ran into the following error: {e}')
                        logger.error(
                            f'As a result instance(s): {instance_ids} may not have been '
                            'started.')
                    else:
                        logger.info(
                            'Successfully initiated a start_instances on the '
                            f'following instance(s): {instance_ids}')


                def main(event = 'test', context = 'none'):
                    '''This is the main handler for stopping and starting ec2 instances.'''

                    chronos_interval = 15
                    stop_tag = "Chronos-stop"
                    start_tag = "Chronos-start"
                    now = dt.now()

                    logger.info(f'event: {event}')
                    
                    all_tags = describe_tags(stop_tag, start_tag)
                    stop_instances, start_instances = filter_stop_and_start(
                        all_tags, now, chronos_interval, stop_tag, start_tag) 


                    if start_instances:
                        start_ec2(start_instances)    
                    
                    if stop_instances:
                        stop_ec2(stop_instances)
            MemorySize: 128
            Role: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/StackSet-Chronos-3c78eaa1-de17-4-ChronosLambdaRole-1LCK21SC65AH6"
            Runtime: "python3.9"
            Timeout: 3

    LambdaFunction5:
        Type: "AWS::Lambda::Function"
        Properties:
            Description: ""
            FunctionName: "StackSet-Enable-S3-Defaul-S3DefaultEncryptionLambd-AfdVsCSZZRKB"
            Handler: "index.lambda_handler"
            Code: 
              ZipFile: |
                import boto3
                import logging
                from botocore.exceptions import ClientError
                
                # Set up the logger
                logger = logging.getLogger()
                logger.setLevel(logging.INFO)
                
                
                def lambda_handler(event, context):
                
                    req_params = event.get('detail').get('requestParameters')
                    s3_bucket = req_params.get('bucketName')
                    access_logging_bucket = s3_bucket.endswith(('-s3-access-logs-us-gov-west-1', 's3-access-logs-us-gov-east-1'))
                    s3 = boto3.client('s3')
                    region = event.get('detail').get('awsRegion')
                    failmesg = f"failed to encrypt bucket {s3_bucket}"
                    key_arn = f"arn:aws:kms:{region}:314679227390:key/mrk-f5796452ded64aad9731f5ee6cd06c27"
                
                    if access_logging_bucket:
                        rules ={
                            'Rules': [
                                {
                                    'ApplyServerSideEncryptionByDefault': {
                                        'SSEAlgorithm': 'AES256'
                                    },
                                    'BucketKeyEnabled': True
                                },
                            ]
                        }
                    else:
                        rules ={
                            'Rules': [
                                {
                                    'ApplyServerSideEncryptionByDefault': {
                                        'SSEAlgorithm': 'aws:kms',
                                        'KMSMasterKeyID': key_arn
                                    },
                                    'BucketKeyEnabled': True
                                },
                            ]
                        }

                
                    try:
                        resp = s3.get_bucket_encryption(Bucket=s3_bucket)
                    except ClientError as e:
                        if e.response['Error']['Code'] == 'ServerSideEncryptionConfigurationNotFoundError':
                            logger.info(f'No Server Side Encryption set on {s3_bucket}.')
                            bucket_rules = dict()
                    except Exception as e:
                        logger.warn(f'get_bucket_encryption failure for {s3_bucket} - {e}')
                        return
                    else:
                        bucket_rules = resp.get(
                            'ServerSideEncryptionConfiguration', {}).get('Rules')[0]
                
                    if bucket_rules.get('BucketKeyEnabled'):
                        kms_key = bucket_rules.get('ApplyServerSideEncryptionByDefault').get('KMSMasterKeyID')
                        if kms_key:
                            if kms_key == key_arn:
                                logger.info(f'Bucket {s3_bucket} already has encryption set without action.')
                                return
                        else:
                            kms_aes256 = True if bucket_rules.get('ApplyServerSideEncryptionByDefault').get('SSEAlgorithm') == 'AES256' else False
                            if access_logging_bucket and kms_aes256:
                                logger.info(f'Bucket {s3_bucket} already has aes256 encryption set without action.')
                                return
                
                    try:
                        resp = s3.put_bucket_encryption(
                            Bucket=s3_bucket,
                            ServerSideEncryptionConfiguration=rules)
                    except ClientError as e:
                        logger.warn(f"{failmesg} - {e.response['Error']['Message']}")
                    except Exception as ex:
                        logger.warn(f"{failmesg} - {ex}")
                    else:
                        logger.info(f"Successfully enabled default encryption on {s3_bucket} - {resp}")
            MemorySize: 128
            Role: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/StackSet-Enable-S3-Defaul-S3DefaultEncryptionLambd-1H0RC12HDOGZB"
            Runtime: "python3.9"
            Timeout: 120

    LambdaFunction6:
        Type: "AWS::Lambda::Function"
        Properties:
            Description: ""
            FunctionName: "IAM_ACCESS_KEY_ROTATED"
            Handler: "lambda_function.lambda_handler"
            Code:
              ZipFile: |
                import json
                from datetime import datetime, timedelta
                import dateutil.parser
                import re
                import boto3
                import botocore

                ##############
                # Parameters #
                ##############

                # Define the default resource to report to Config Rules
                DEFAULT_RESOURCE_TYPE = 'AWS::IAM::User'
                DEFAULT_NUMBER_OF_DAYS = 90

                # Set to True to get the lambda to assume the Role attached on the Config Service (useful for cross-account).
                ASSUME_ROLE_MODE = False

                #############
                # Main Code #
                #############

                def evaluate_compliance(event, configuration_item, valid_rule_parameters):
                    """Form the evaluation(s) to be return to Config Rules

                    Return either:
                    None -- when no result needs to be displayed
                    a string -- either COMPLIANT, NON_COMPLIANT or NOT_APPLICABLE
                    a dictionary -- the evaluation dictionary, usually built by build_evaluation_from_config_item()
                    a list of dictionary -- a list of evaluation dictionary , usually built by build_evaluation()

                    Keyword arguments:
                    event -- the event variable given in the lambda handler
                    configuration_item -- the configurationItem dictionary in the invokingEvent
                    valid_rule_parameters -- the output of the evaluate_parameters() representing validated parameters of the Config Rule

                    Advanced Notes:
                    1 -- if a resource is deleted and generate a configuration change with ResourceDeleted status, the Boilerplate code will put a NOT_APPLICABLE on this resource automatically.
                    2 -- if a None or a list of dictionary is returned, the old evaluation(s) which are not returned in the new evaluation list are returned as NOT_APPLICABLE by the Boilerplate code
                    3 -- if None or an empty string, list or dict is returned, the Boilerplate code will put a "shadow" evaluation to feedback that the evaluation took place properly
                    """

                    iam_client = get_client('iam', event)
                    evaluations = []

                    users_list = get_all_users(iam_client)

                    if not users_list:
                        return None

                    for user in users_list:
                        if user['UserId'] in valid_rule_parameters['WhitelistedUserList']:
                            evaluations.append(build_evaluation(user['UserId'], 'COMPLIANT', event, annotation='This user ({}) is whitelisted.'.format(user['UserId'])))
                            continue
                        keys_list = iam_client.list_access_keys(UserName=user['UserName'])
                        expired_key = False
                        for key in keys_list['AccessKeyMetadata']:
                            if key['Status'] == 'Inactive':
                                continue
                            if not is_key_still_valid(key['CreateDate'], valid_rule_parameters['KeyActiveTimeOutInDays']):
                                expired_key = True
                                evaluations.append(build_evaluation(user['UserId'], 'NON_COMPLIANT', event, annotation='This user ({}) has an expired active access key ({}). The key is older than {}. It must be no older than {} days.'.format(user['UserId'], key['AccessKeyId'], str(key_age(key['CreateDate'])).split(',')[0], valid_rule_parameters['KeyActiveTimeOutInDays'])))
                                break
                        if not expired_key:
                            evaluations.append(build_evaluation(user['UserId'], 'COMPLIANT', event))

                    return evaluations

                def get_all_users(client):
                    list_to_return = []
                    user_list = client.list_users()
                    while True:
                        for user in user_list['Users']:
                            list_to_return.append(user)
                        if 'Marker' in user_list:
                            user_list = client.list_users(Marker=user_list['Marker'])
                        else:
                            break
                    return list_to_return

                def is_key_still_valid(create_date, timeout_days):
                    expiry_time = timedelta(days=timeout_days)
                    if expiry_time > key_age(create_date):
                        return True
                    return False

                def key_age(create_date):
                    today = datetime.utcnow().replace(tzinfo=dateutil.tz.tzutc())
                    time_delta = today - create_date
                    return time_delta    

                def evaluate_parameters(rule_parameters):
                    """Evaluate the rule parameters dictionary validity. Raise a ValueError for invalid parameters.

                    Return:
                    anything suitable for the evaluate_compliance()

                    Keyword arguments:
                    rule_parameters -- the Key/Value dictionary of the Config Rules parameters
                    """

                    valid_rule_parameters = {}

                    valid_rule_parameters['WhitelistedUserList'] = []
                    if 'WhitelistedUserList' in rule_parameters:
                        whitelisted_users = rule_parameters['WhitelistedUserList'].replace(' ', '').split(',')
                        valid_whitelist = []
                        for whitelisted_user in whitelisted_users:
                            if not re.match("^AIDA[A-Z0-9]+$", whitelisted_user):
                                raise ValueError('Invalid Parameter WhitelistedUser: ' + whitelisted_user)
                            valid_whitelist.append(whitelisted_user)
                        valid_rule_parameters['WhitelistedUserList'] = valid_whitelist

                    valid_rule_parameters['KeyActiveTimeOutInDays'] = DEFAULT_NUMBER_OF_DAYS
                    if 'KeyActiveTimeOutInDays' in rule_parameters:
                        try:
                            valid_rule_parameters['KeyActiveTimeOutInDays'] = int(str(rule_parameters['KeyActiveTimeOutInDays']))
                        except:
                            raise ValueError("Invalid Parameter KeyActiveTimeOutInDays: not an integer.")

                    if valid_rule_parameters['KeyActiveTimeOutInDays'] < 0:
                        raise ValueError("Invalid Parameter KeyActiveTimeOutInDays: use a positive value.")

                    if valid_rule_parameters['KeyActiveTimeOutInDays'] > 999999999:
                        raise ValueError("Invalid Parameter KeyActiveTimeOutInDays: use a value less than 999999999.")

                    return valid_rule_parameters

                ####################
                # Helper Functions #
                ####################

                # Build an error to be displayed in the logs when the parameter is invalid.
                def build_parameters_value_error_response(ex):
                    """Return an error dictionary when the evaluate_parameters() raises a ValueError.
                    Keyword arguments:
                    ex -- Exception text
                    """
                    return build_error_response(internalErrorMessage="Parameter value is invalid",
                                                internalErrorDetails="An ValueError was raised during the validation of the Parameter value",
                                                customerErrorCode="InvalidParameterValueException",
                                                customerErrorMessage=str(ex))

                # This gets the client after assuming the Config service role
                # either in the same AWS account or cross-account.
                def get_client(service, event):
                    """Return the service boto client. It should be used instead of directly calling the client.

                    Keyword arguments:
                    service -- the service name used for calling the boto.client()
                    event -- the event variable given in the lambda handler
                    """
                    if not ASSUME_ROLE_MODE:
                        return boto3.client(service)
                    credentials = get_assume_role_credentials(event["executionRoleArn"])
                    return boto3.client(service, aws_access_key_id=credentials['AccessKeyId'],
                                        aws_secret_access_key=credentials['SecretAccessKey'],
                                        aws_session_token=credentials['SessionToken']
                                      )

                # This generate an evaluation for config
                def build_evaluation(resource_id, compliance_type, event, resource_type=DEFAULT_RESOURCE_TYPE, annotation=None):
                    """Form an evaluation as a dictionary. Usually suited to report on scheduled rules.

                    Keyword arguments:
                    resource_id -- the unique id of the resource to report
                    compliance_type -- either COMPLIANT, NON_COMPLIANT or NOT_APPLICABLE
                    event -- the event variable given in the lambda handler
                    resource_type -- the CloudFormation resource type (or AWS::::Account) to report on the rule (default DEFAULT_RESOURCE_TYPE)
                    annotation -- an annotation to be added to the evaluation (default None)
                    """
                    eval_cc = {}
                    if annotation:
                        eval_cc['Annotation'] = annotation
                    eval_cc['ComplianceResourceType'] = resource_type
                    eval_cc['ComplianceResourceId'] = resource_id
                    eval_cc['ComplianceType'] = compliance_type
                    eval_cc['OrderingTimestamp'] = str(json.loads(event['invokingEvent'])['notificationCreationTime'])
                    return eval_cc

                def build_evaluation_from_config_item(configuration_item, compliance_type, annotation=None):
                    """Form an evaluation as a dictionary. Usually suited to report on configuration change rules.

                    Keyword arguments:
                    configuration_item -- the configurationItem dictionary in the invokingEvent
                    compliance_type -- either COMPLIANT, NON_COMPLIANT or NOT_APPLICABLE
                    annotation -- an annotation to be added to the evaluation (default None)
                    """
                    eval_ci = {}
                    if annotation:
                        eval_ci['Annotation'] = annotation
                    eval_ci['ComplianceResourceType'] = configuration_item['resourceType']
                    eval_ci['ComplianceResourceId'] = configuration_item['resourceId']
                    eval_ci['ComplianceType'] = compliance_type
                    eval_ci['OrderingTimestamp'] = configuration_item['configurationItemCaptureTime']
                    return eval_ci

                ####################
                # Boilerplate Code #
                ####################

                # Helper function used to validate input
                def check_defined(reference, reference_name):
                    if not reference:
                        raise Exception('Error: ', reference_name, 'is not defined')
                    return reference

                # Check whether the message is OversizedConfigurationItemChangeNotification or not
                def is_oversized_changed_notification(message_type):
                    check_defined(message_type, 'messageType')
                    return message_type == 'OversizedConfigurationItemChangeNotification'

                # Check whether the message is a ScheduledNotification or not.
                def is_scheduled_notification(message_type):
                    check_defined(message_type, 'messageType')
                    return message_type == 'ScheduledNotification'

                # Get configurationItem using getResourceConfigHistory API
                # in case of OversizedConfigurationItemChangeNotification
                def get_configuration(resource_type, resource_id, configuration_capture_time):
                    result = AWS_CONFIG_CLIENT.get_resource_config_history(
                        resourceType=resource_type,
                        resourceId=resource_id,
                        laterTime=configuration_capture_time,
                        limit=1)
                    configurationItem = result['configurationItems'][0]
                    return convert_api_configuration(configurationItem)

                # Convert from the API model to the original invocation model
                def convert_api_configuration(configurationItem):
                    for k, v in configurationItem.items():
                        if isinstance(v, datetime.datetime):
                            configurationItem[k] = str(v)
                    configurationItem['awsAccountId'] = configurationItem['accountId']
                    configurationItem['ARN'] = configurationItem['arn']
                    configurationItem['configurationStateMd5Hash'] = configurationItem['configurationItemMD5Hash']
                    configurationItem['configurationItemVersion'] = configurationItem['version']
                    configurationItem['configuration'] = json.loads(configurationItem['configuration'])
                    if 'relationships' in configurationItem:
                        for i in range(len(configurationItem['relationships'])):
                            configurationItem['relationships'][i]['name'] = configurationItem['relationships'][i]['relationshipName']
                    return configurationItem

                # Based on the type of message get the configuration item
                # either from configurationItem in the invoking event
                # or using the getResourceConfigHistiry API in getConfiguration function.
                def get_configuration_item(invokingEvent):
                    check_defined(invokingEvent, 'invokingEvent')
                    if is_oversized_changed_notification(invokingEvent['messageType']):
                        configurationItemSummary = check_defined(invokingEvent['configurationItemSummary'], 'configurationItemSummary')
                        return get_configuration(configurationItemSummary['resourceType'], configurationItemSummary['resourceId'], configurationItemSummary['configurationItemCaptureTime'])
                    elif is_scheduled_notification(invokingEvent['messageType']):
                        return None
                    return check_defined(invokingEvent['configurationItem'], 'configurationItem')

                # Check whether the resource has been deleted. If it has, then the evaluation is unnecessary.
                def is_applicable(configurationItem, event):
                    try:
                        check_defined(configurationItem, 'configurationItem')
                        check_defined(event, 'event')
                    except:
                        return True
                    status = configurationItem['configurationItemStatus']
                    eventLeftScope = event['eventLeftScope']
                    if status == 'ResourceDeleted':
                        print("Resource Deleted, setting Compliance Status to NOT_APPLICABLE.")
                    return (status == 'OK' or status == 'ResourceDiscovered') and not eventLeftScope

                def get_assume_role_credentials(role_arn):
                    sts_client = boto3.client('sts')
                    try:
                        assume_role_response = sts_client.assume_role(RoleArn=role_arn, RoleSessionName="configLambdaExecution")
                        return assume_role_response['Credentials']
                    except botocore.exceptions.ClientError as ex:
                        # Scrub error message for any internal account info leaks
                        print(str(ex))
                        if 'AccessDenied' in ex.response['Error']['Code']:
                            ex.response['Error']['Message'] = "AWS Config does not have permission to assume the IAM role."
                        else:
                            ex.response['Error']['Message'] = "InternalError"
                            ex.response['Error']['Code'] = "InternalError"
                        raise ex

                # This removes older evaluation (usually useful for periodic rule not reporting on AWS::::Account).
                def clean_up_old_evaluations(latest_evaluations, event):

                    cleaned_evaluations = []

                    old_eval = AWS_CONFIG_CLIENT.get_compliance_details_by_config_rule(
                        ConfigRuleName=event['configRuleName'],
                        ComplianceTypes=['COMPLIANT', 'NON_COMPLIANT'],
                        Limit=100)

                    old_eval_list = []

                    while True:
                        for old_result in old_eval['EvaluationResults']:
                            old_eval_list.append(old_result)
                        if 'NextToken' in old_eval:
                            next_token = old_eval['NextToken']
                            old_eval = AWS_CONFIG_CLIENT.get_compliance_details_by_config_rule(
                                ConfigRuleName=event['configRuleName'],
                                ComplianceTypes=['COMPLIANT', 'NON_COMPLIANT'],
                                Limit=100,
                                NextToken=next_token)
                        else:
                            break

                    for old_eval in old_eval_list:
                        old_resource_id = old_eval['EvaluationResultIdentifier']['EvaluationResultQualifier']['ResourceId']
                        newer_founded = False
                        for latest_eval in latest_evaluations:
                            if old_resource_id == latest_eval['ComplianceResourceId']:
                                newer_founded = True
                        if not newer_founded:
                            cleaned_evaluations.append(build_evaluation(old_resource_id, "NOT_APPLICABLE", event))

                    return cleaned_evaluations + latest_evaluations

                # This decorates the lambda_handler in rule_code with the actual PutEvaluation call
                def lambda_handler(event, context):

                    global AWS_CONFIG_CLIENT

                    #print(event)
                    check_defined(event, 'event')
                    invoking_event = json.loads(event['invokingEvent'])
                    rule_parameters = {}
                    if 'ruleParameters' in event:
                        rule_parameters = json.loads(event['ruleParameters'])

                    try:
                        valid_rule_parameters = evaluate_parameters(rule_parameters)
                    except ValueError as ex:
                        return build_parameters_value_error_response(ex)

                    try:
                        AWS_CONFIG_CLIENT = get_client('config', event)
                        if invoking_event['messageType'] in ['ConfigurationItemChangeNotification', 'ScheduledNotification', 'OversizedConfigurationItemChangeNotification']:
                            configuration_item = get_configuration_item(invoking_event)
                            if is_applicable(configuration_item, event):
                                compliance_result = evaluate_compliance(event, configuration_item, valid_rule_parameters)
                            else:
                                compliance_result = "NOT_APPLICABLE"
                        else:
                            return build_internal_error_response('Unexpected message type', str(invoking_event))
                    except botocore.exceptions.ClientError as ex:
                        if is_internal_error(ex):
                            return build_internal_error_response("Unexpected error while completing API request", str(ex))
                        return build_error_response("Customer error while making API request", str(ex), ex.response['Error']['Code'], ex.response['Error']['Message'])
                    except ValueError as ex:
                        return build_internal_error_response(str(ex), str(ex))

                    evaluations = []
                    latest_evaluations = []

                    if not compliance_result:
                        latest_evaluations.append(build_evaluation(event['accountId'], "NOT_APPLICABLE", event, resource_type='AWS::::Account'))
                        evaluations = clean_up_old_evaluations(latest_evaluations, event)
                    elif isinstance(compliance_result, str):
                        if configuration_item:
                            evaluations.append(build_evaluation_from_config_item(configuration_item, compliance_result))
                        else:
                            evaluations.append(build_evaluation(event['accountId'], compliance_result, event, resource_type=DEFAULT_RESOURCE_TYPE))
                    elif isinstance(compliance_result, list):
                        for evaluation in compliance_result:
                            missing_fields = False
                            for field in ('ComplianceResourceType', 'ComplianceResourceId', 'ComplianceType', 'OrderingTimestamp'):
                                if field not in evaluation:
                                    print("Missing " + field + " from custom evaluation.")
                                    missing_fields = True

                            if not missing_fields:
                                latest_evaluations.append(evaluation)
                        evaluations = clean_up_old_evaluations(latest_evaluations, event)
                    elif isinstance(compliance_result, dict):
                        missing_fields = False
                        for field in ('ComplianceResourceType', 'ComplianceResourceId', 'ComplianceType', 'OrderingTimestamp'):
                            if field not in compliance_result:
                                print("Missing " + field + " from custom evaluation.")
                                missing_fields = True
                        if not missing_fields:
                            evaluations.append(compliance_result)
                    else:
                        evaluations.append(build_evaluation_from_config_item(configuration_item, 'NOT_APPLICABLE'))

                    # Put together the request that reports the evaluation status
                    resultToken = event['resultToken']
                    testMode = False
                    if resultToken == 'TESTMODE':
                        # Used solely for RDK test to skip actual put_evaluation API call
                        testMode = True
                    # Invoke the Config API to report the result of the evaluation
                    evaluation_copy = []
                    evaluation_copy = evaluations[:]
                    while(evaluation_copy):
                        AWS_CONFIG_CLIENT.put_evaluations(Evaluations=evaluation_copy[:100], ResultToken=resultToken, TestMode=testMode)
                        del evaluation_copy[:100]
                    # Used solely for RDK test to be able to test Lambda function
                    return evaluations

                def is_internal_error(exception):
                    return ((not isinstance(exception, botocore.exceptions.ClientError)) or exception.response['Error']['Code'].startswith('5')
                            or 'InternalError' in exception.response['Error']['Code'] or 'ServiceError' in exception.response['Error']['Code'])

                def build_internal_error_response(internalErrorMessage, internalErrorDetails=None):
                    return build_error_response(internalErrorMessage, internalErrorDetails, 'InternalError', 'InternalError')

                def build_error_response(internalErrorMessage, internalErrorDetails=None, customerErrorCode=None, customerErrorMessage=None):
                    error_response = {
                        'internalErrorMessage': internalErrorMessage,
                        'internalErrorDetails': internalErrorDetails,
                        'customerErrorMessage': customerErrorMessage,
                        'customerErrorCode': customerErrorCode
                    }
                    print(error_response)
                    return error_response 
            MemorySize: 128
            Role: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/service-role/IAM_ACCESS_KEY_ROTATED-role-x58uyjup"
            Runtime: "python3.8"
            Timeout: 3

    LambdaFunction7: #  -- invoke function
        Type: "AWS::Lambda::Function"
        Properties:
            Description: ""
            FunctionName: "StackSet-Enable-S3-Block--S3BlockPublicAccessLambd-GCNSqxU2edUy"
            Handler: "index.handler"
            Code: 
              ZipFile: |
                import boto3
                import cfnresponse
                from botocore.exceptions import ClientError
              
                def handler(event, context):
                    cfn_request = event['RequestType']
                    block_public_access = {
                      'BlockPublicAcls': bool(event['ResourceProperties']['BlockPublicAcls']),
                      'IgnorePublicAcls': bool(event['ResourceProperties']['BlockPublicPolicy']),
                      'BlockPublicPolicy': bool(event['ResourceProperties']['IgnorePublicAcls']),
                      'RestrictPublicBuckets': bool(event['ResourceProperties']['RestrictPublicBuckets'])}
                    s3control = boto3.client('s3control')
                    
                    def handle_errors(error, error_type = 'Exception'):
                        
                        error_message = f'Failed to {cfn_request} S3 block public access settings - '
                        if type != 'Exception':
                            error_message =+ error
                            print(error_message)
                            cfnresponse.send(
                                event, context, cfnresponse.FAILED, error.response)
                        else:
                            error_message =+ error
                            print(error_message)
                            cfnresponse.send(
                                event, context, cfnresponse.FAILED, str(error))

                    try:
                        aws_id = context.invoked_function_arn.split(":")[4]
                    except Exception as e:
                        handle_errors(e)
                        return
                    else:
                        if cfn_request == 'Create' or cfn_request == 'Update':
                            try:
                                response = s3control.put_public_access_block(
                                    AccountId=aws_id,
                                    PublicAccessBlockConfiguration=block_public_access)
                            except ClientError as e:
                                handle_errors(e, 'ClientError')
                                return
                            except Exception as e:
                                handle_errors(e)
                                return
                        elif cfn_request == 'Delete':
                            try:
                                resp = s3control.delete_public_access_block(
                                    AccountId=aws_id)
                            except ClientError as e:
                                handle_errors(e, 'ClientError')
                                return
                            except Exception as e:
                                handle_errors(e)
                                return

                    print("Respond: SUCCESS")
                    cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                    return  
            MemorySize: 128
            Role: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/StackSet-Enable-S3-Block-S3BlockPublicAccessLambd-1I9CCEY5M5VSF"
            Runtime: "python3.8"
            Timeout: 120

    LambdaFunction8: # -- invoke function
        Type: "AWS::Lambda::Function"
        Properties:
            Description: ""
            FunctionName: "StackSet-CMK-EBS-Encrypti-Ec2DefaultEncryptionLamb-TkNr4zBwA78z"
            Handler: "index.handler"
            Code: 
              ZipFile: |
                import boto3
                import cfnresponse
                from botocore.exceptions import ClientError

                
                def handler(event, context):

                    cfn_request = event['RequestType']
                    ec2 = boto3.client('ec2')
                    fail_mesg = f"FAILED to {cfn_request} enable_ebs_encryption_by_default"              
                    cfn_kms_key_alias = event.get('ResourceProperties', {}).get('KmsKeyAlias')
                    cfn_kms_account = event.get('ResourceProperties', {}).get('KmsKeySharingAccount')
                    region = context.invoked_function_arn.split(':')[3]
                    
                    if cfn_kms_key_alias is None:
                        print(
                            f"{fail_mesg} - No key specified")
                        cfnresponse.send(
                            event, context, cfnresponse.FAILED, fail_mesg)
                        return 
                    else:
                        kms_cmk_alias_arn = f'arn:aws:kms:{region}:{cfn_kms_account}:{cfn_kms_key_alias}'
                
                    if cfn_request == 'Create' or cfn_request == 'Update':
                        try:
                            resp = ec2.enable_ebs_encryption_by_default()
                            if cfn_kms_key_alias == "" or cfn_kms_key_alias == 'aws/ebs':
                                ec2.reset_ebs_default_kms_key_id()
                            else:
                                ec2.modify_ebs_default_kms_key_id(KmsKeyId=kms_cmk_alias_arn)
                
                        except ClientError as e:
                            print(
                                f"{fail_mesg} - {e.response['Error']['Message']}")
                            cfnresponse.send(
                                event, context, cfnresponse.FAILED, e.response)
                            return
                        except Exception as ex:
                            print(f"{fail_mesg} - {ex}")
                            cfnresponse.send(
                                event, context, cfnresponse.FAILED, str(ex))
                            return
                  
                    elif cfn_request == 'Delete':
                        try:
                            ec2.disable_ebs_encryption_by_default()
                
                        except ClientError as e:
                            print(
                                f"{fail_mesg} - {e.response['Error']['Message']}")
                            cfnresponse.send(
                                event, context, cfnresponse.FAILED, exception.response)
                            return
                        except Exception as ex:
                            print(f"{fail_mesg} - {ex}")
                            cfnresponse.send(
                                event, context, cfnresponse.FAILED, str(ex))
                            return
                  
                    print(f"SUCCESS - {cfn_request} enable_ebs_encryption_by_delault")
                    cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                    return
            MemorySize: 128
            Role: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/StackSet-CMK-EBS-Encrypti-Ec2DefaultEncryptionLamb-12XJHSL1JPY22"
            Runtime: "python3.8"
            Timeout: 120

    LambdaFunction9: # -- invoke function
        Type: "AWS::Lambda::Function"
        Properties:
            Description: ""
            FunctionName: "CloudSSnorkel-CloudWatch2S3--LogSubscriberFunction-MWTNjhPRxsEz"
            Handler: "index.handler"
            Code: 
              ZipFile: |
                import traceback
                import boto3
                import botocore.exceptions
                import cfnresponse

                logs_client = boto3.client("logs")


                def subscribe(log_group_name):
                    print("Subscribe ", log_group_name)

                    if log_group_name.startswith("/aws/lambda/CloudSSnorkel-CloudWatch2S3-additional-account") \
                            or log_group_name.startswith("/aws/kinesisfirehose/CloudSSnorkel-CloudWatch2S3-additional-account"):
                        print("Skipping our log groups to avoid endless recursion")
                        return

                    try:
                        logs_client.put_subscription_filter(
                            logGroupName=log_group_name,
                            filterName="BucketBackupFilter",
                            filterPattern="",
                            destinationArn="arn:aws:logs:us-gov-west-1:314626598057:destination:BucketBackupLogDestination",
                        )
                    except logs_client.exceptions.LimitExceededException:
                        print(f"ERROR: Unable to subscribe to {log_group_name} as it already has an active subscription")


                def matched_log_groups(prefix):
                    print(f"Finding all log groups with prefix '{prefix}'")

                    log_group_paginator = logs_client.get_paginator("describe_log_groups")

                    paginate_params = {}
                    if prefix:
                        paginate_params["logGroupNamePrefix"] = prefix

                    for log_group_page in log_group_paginator.paginate(**paginate_params):
                        for log_group in log_group_page["logGroups"]:
                            yield log_group["logGroupName"]


                def subscribe_all():
                    for log_group_name in matched_log_groups(""):
                        subscribe(log_group_name)


                def unsubscribe_all():
                    for log_group_name in matched_log_groups(""):
                        print("Unsubscribe ", log_group_name)

                        try:
                            logs_client.delete_subscription_filter(
                                logGroupName=log_group_name,
                                filterName="BucketBackupFilter",
                            )
                        except botocore.exceptions.ClientError:
                            pass


                def handler(event, context):
                    print('event:', event)

                    if "ResponseURL" in event and "RequestType" in event:
                        # custom resource callback
                        try:
                            if event["RequestType"] in ["Create", "Update"]:
                                print("Subscribe to all new log groups on resource", event["RequestType"])
                                subscribe_all()

                            elif event["RequestType"] == "Delete":
                                print("Unsubscribe all on resource", event["RequestType"])
                                unsubscribe_all()

                            cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, "ok")

                        except Exception as e:
                            try:
                                traceback.print_last()
                            except ValueError:
                                print("Caught exception but unable to print stack trace")
                                print(e)
                            cfnresponse.send(event, context, cfnresponse.FAILED, {}, "fail")

                    else:
                        # other call
                        detail_type = event.get("detail-type")

                        if detail_type == "AWS API Call via CloudTrail":
                            print("Subscribe to specific new log group from CloudTrail")

                            request_parameters = event['detail']['requestParameters']

                            if request_parameters:
                                log_group_name = request_parameters['logGroupName']

                                if log_group_name.startswith(""):
                                    subscribe(log_group_name)
                                else:
                                    print(log_group_name, "doesn't match required prefix ''")

                            else:
                                print("Bad parameters")

                        elif detail_type == "Scheduled Event":
                            print("Subscribe to all new log groups on schedule")

                            subscribe_all()

                        else:
                            print("Subscribe to all new log groups")

                            subscribe_all()
            MemorySize: 128
            Role: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/CloudSSnorkel-CloudWatch2S3-addi-LogSubscriberRole-QN0CSDTF91QN"
            Runtime: "python3.6"
            Timeout: 300

    LambdaFunction10:
        Type: "AWS::Lambda::Function"
        Properties:
            Description: ""
            FunctionName: "iamUserCleanUp"
            Handler: "lambda_function.lambda_handler"
            Code: 
              ZipFile: |
                import json
                import boto3
                import datetime
                import time
                import os

                minAgeKeysToReport = int(os.environ['MinAgeKeysToReport'])
                minAgeKeysToDisable = int(os.environ['MinAgeKeysToDisable'])
                minAgeKeysToDelete = int(os.environ['MinAgeKeysToDelete'])
                minAgeUnusedUsersToReport = int(os.environ['MinAgeUnusedUsersToReport'])
                minAgeUnusedUsersToDisable = int(os.environ['MinAgeUnusedUsersToDisable'])
                minAgeUnusedUsersToDelete = int(os.environ['MinAgeUnusedUsersToDelete'])
                minAgeRolesToReport = int(os.environ['MinAgeRolesToReport'])
                minAgeRolesToDisable = int(os.environ['MinAgeRolesToDisable'])
                minAgeRolesToDelete = int(os.environ['MinAgeRolesToDelete'])
                CleanupAnalyzerArn = os.environ['CleanupAnalyzer']

                def lambda_handler(event, context):
                    client = boto3.client('iam')
                    
                    today = datetime.datetime.now()
                    
                    report = ''
                    
                    # Iterate over all the users
                    userResponse = client.list_users()
                    for u in userResponse['Users']:
                        # Work out when the user was last used
                        passwordLastUsed = u['PasswordLastUsed'] if 'PasswordLastUsed' in u else u['CreateDate']
                        daysSinceUsed = (today - passwordLastUsed.replace(tzinfo=None)).days
                        deleted = False
                        # If the feature is enabled (>0) and the days since used > delete setting
                        if (minAgeUnusedUsersToDelete > 0 and daysSinceUsed >= minAgeUnusedUsersToDelete):
                            # Delete the user
                            client.delete_user(UserName=u['UserName'])
                            report += 'User {0} has not logged in since {1} and has been deleted\n'.format(
                                u['UserName'],
                                passwordLastUsed)
                            deleted = True
                        # else, if the features is enabled and the days since used > disable setting
                        elif (minAgeUnusedUsersToDelete > 0 and daysSinceUsed >= minAgeUnusedUsersToDisable):
                            # Force a password reset
                            client.update_login_profile(
                                UserName=u['UserName'],
                                PasswordResetRequired=True)
                            report += 'User {0} has not logged in since {1} and has been disabled\n'.format(
                                u['UserName'],
                                passwordLastUsed)
                        # else, if the days since used > report setting
                        elif (daysSinceUsed >= minAgeUnusedUsersToReport):
                            # add the user to the report
                            report += 'User {0} has not logged in since {1} and needs cleanup\n'.format(
                                u['UserName'],
                                passwordLastUsed)
                        
                        # If we haven't deleted the user
                        if not deleted:
                            # Get their access keys
                            keysResponse = client.list_access_keys(
                                UserName=u['UserName'])
                            # For each of their keys
                            for k in keysResponse['AccessKeyMetadata']:
                                # Get when the key was last used
                                lastUsedResponse = client.get_access_key_last_used(AccessKeyId=k['AccessKeyId'])
                                keyLastUsed = lastUsedResponse['AccessKeyLastUsed']['LastUsedDate'] if 'LastUsedDate' in lastUsedResponse['AccessKeyLastUsed'] else k['CreateDate']
                                daysSinceUsed = (today - keyLastUsed.replace(tzinfo=None)).days
                                # If the feature is enabled (>0) and the days since used > delete setting
                                if (minAgeKeysToDelete > 0 and daysSinceUsed >= minAgeKeysToDelete):
                                    # Delete the key
                                    client.delete_user(UserName=u['UserName'])
                                    response = client.delete_access_key(
                                        UserName=u['UserName'],
                                        AccessKeyId=k['AccessKeyId']
                                    )
                                    report += 'User {0} has not used access key {1} in since {2} and has been deleted\n'.format(
                                        u['UserName'],
                                        k['AccessKeyId'],
                                        keyLastUsed)
                                # else, if the features is enabled and the days since used > disable setting
                                elif (minAgeKeysToDisable > 0 and daysSinceUsed >= minAgeKeysToDisable):
                                    # Force a password reset
                                    response = client.update_access_key(
                                        UserName=u['UserName'],
                                        AccessKeyId=k['AccessKeyId'],
                                        Status='Inactive'
                                    )
                                    report += 'User {0} has not used access key {1} in since {2} and has been disabled\n'.format(
                                        u['UserName'],
                                        k['AccessKeyId'],
                                        keyLastUsed)
                                # else, if the days since used > report setting
                                elif (daysSinceUsed >= minAgeKeysToReport):
                                    # add the user to the report
                                    report += 'User {0} has not used access key {1} in since {2} and needs cleanup\n'.format(
                                        u['UserName'],
                                        k['AccessKeyId'],
                                        keyLastUsed)
                        
                    # Iterate over all the roles
                    rolesResponse = client.list_roles(MaxItems=1000)
                    for r in [r for r in rolesResponse['Roles'] if '/aws-service-role/' not in r['Path'] and '/service-role/' not in r['Path']]:
                        # We need to create a job to generate the last access report
                        jobId = client.generate_service_last_accessed_details(Arn=r['Arn'])['JobId']
                        
                        roleAccessDetails = client.get_service_last_accessed_details(JobId=jobId)
                        jobAttempt = 0
                        while roleAccessDetails['JobStatus'] == 'IN_PROGRESS':
                            time.sleep(jobAttempt*2) 
                            jobAttempt = jobAttempt + 1
                            roleAccessDetails = client.get_service_last_accessed_details(JobId=jobId)
                        if roleAccessDetails['JobStatus'] == 'FAILED':
                            report += 'Unable to retrive last access report for role {0}. No action taken.\n'.format(
                                    r['Arn'])
                        else:
                            lastAccessedDates = [a['LastAuthenticated'] for a in roleAccessDetails['ServicesLastAccessed'] if 'LastAuthenticated' in a]
                            if not lastAccessedDates:
                                report += 'Role {0} has no access history. No action taken.\n'.format(
                                        r['Arn'])
                            else:
                                roleLastUsed = min(lastAccessedDates)
                                daysSinceUsed = (today - roleLastUsed.replace(tzinfo=None)).days
                                # If the feature is enabled (>0) and the days since used > delete setting
                                if (minAgeRolesToDelete > 0 and daysSinceUsed >= minAgeRolesToDelete):
                                    # Delete the user
                                    client.delete_role(RoleName=r['RoleName'])
                                    report += 'Role {0} has not been used since {1} and has been deleted\n'.format(
                                        r['Arn'],
                                        roleLastUsed)
                                # else, if the features is enabled and the days since used > disable setting
                                elif (minAgeRolesToDelete > 0 and daysSinceUsed >= minAgeRolesToDelete):
                                    # Force a password reset
                                    client.attach_role_policy(
                                        PolicyArn='arn:aws:iam::aws:policy/AWSDenyAll',
                                        RoleName=r['RoleName'],
                                    )
                                    report += 'Role {0} has not been used since {1} and has been disabled\n'.format(
                                        r['Arn'],
                                        roleLastUsed)
                                # else, if the days since used > report setting
                                elif (daysSinceUsed >= minAgeRolesToReport):
                                    # add the user to the report
                                    print(r)
                                    report += 'Role {0} has not been used since {1} and needs cleanup\n'.format(
                                        r['Arn'],
                                        roleLastUsed)

                    # Get all findings from access analyzer if enabled
                    if CleanupAnalyzerArn:
                        analyzerClient = boto3.client('accessanalyzer')
                        findings = analyzerClient.list_findings(analyzerArn=CleanupAnalyzerArn)
                        filteredFindings = [f for f in findings['findings'] if f['status'] == 'ACTIVE'] # filter just active ones
                        for f in filteredFindings:
                            report += 'Principal {0} has permission to {1} against {2} {3}. See finding {4} in IAM Access Analyzer for more information or to archive this finding.\n'.format(
                            f['principal'],
                            f['action'],
                            f['resourceType'],
                            f['resource'],
                            f['id'])
                    
                    if not report:
                        report = 'IAM user cleanup successfully ran. No outstanding users found.'
                    else:
                        report = 'IAM user cleanup successfully ran.\n\n' + report
                    
                    snsClient = boto3.client('sns')
                    snsClient.publish(
                        TopicArn=os.environ['TopicTarget'],
                        Subject='IAM user cleanup from ' +  context.invoked_function_arn.split(":")[4],
                        Message=report
                    )
            MemorySize: 128
            Role: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/service-role/iamUserCleanUp-role-vzaub88e"
            Runtime: "python3.9"
            Timeout: 3